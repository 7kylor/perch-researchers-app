<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="Content-Security-Policy" content="default-src 'self'; script-src 'self' 'unsafe-inline' blob:; worker-src 'self' blob:; style-src 'self' 'unsafe-inline'; img-src 'self' data: blob:; font-src 'self'; connect-src 'self' ws:; object-src 'none'; base-uri 'self'">
  <title>PDF Reader</title>
  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }
    :root {
      --bg: #ffffff; --surface: #f8f9fa; --surface-secondary: #e9ecef; --surface-elevated: #dee2e6;
      --text: #000000; --text-secondary: #495057; --muted: #6c757d; --primary: #3b82f6; --primary-hover: #2563eb;
      --border: #dee2e6; --border-subtle: #e9ecef; --ring: #3b82f6; --sidebar-bg: #f1f3f4;
      --card-hover: rgba(59,130,246,.05); --card-hover-strong: rgba(59,130,246,.1);
      --shadow-sm: 0 1px 2px rgba(0,0,0,.1); --shadow-md: 0 4px 6px -1px rgba(0,0,0,.15);
      --shadow-lg: 0 10px 15px -3px rgba(0,0,0,.2); --shadow-xl: 0 20px 25px -5px rgba(0,0,0,.25);
    }
    :root[data-theme="dark"] {
      --bg: #000; --surface: #1a1a1a; --surface-secondary: #2a2a2a; --surface-elevated: #333;
      --text: #fff; --text-secondary: #ccc; --muted: #888; --primary: #3b82f6; --primary-hover: #2563eb;
      --border: #404040; --border-subtle: #2a2a2a; --ring: #3b82f6; --sidebar-bg: #111;
      --card-hover: rgba(59,130,246,.1); --card-hover-strong: rgba(59,130,246,.2);
      --shadow-sm: 0 1px 2px rgba(0,0,0,.3); --shadow-md: 0 4px 6px -1px rgba(0,0,0,.4);
      --shadow-lg: 0 10px 15px -3px rgba(0,0,0,.5); --shadow-xl: 0 20px 25px -5px rgba(0,0,0,.6);
    }
    body { font-family: -apple-system,BlinkMacSystemFont,'Segoe UI',Roboto,sans-serif; background: var(--bg); color: var(--text); overflow: hidden; }
    .app { height: 100vh; display: flex; flex-direction: column; }
    .header { background: var(--surface); border-bottom: 1px solid var(--border); padding: 16px 24px; display: flex; align-items: center; justify-content: space-between; min-height: 70px; }
    .paper-info { display: flex; flex-direction: column; gap: 4px; }
    .paper-title { font-size: 18px; font-weight: 600; color: var(--text); margin: 0; max-width: 400px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
    .paper-meta { font-size: 14px; color: var(--text-secondary); margin: 0; }
    .controls { display: flex; align-items: center; }
    .control-btn { background: var(--surface-secondary); border: 1px solid var(--border); color: var(--text); border-radius: 6px; padding: 8px 12px; cursor: pointer; font-size: 14px; transition: .2s; display: flex; align-items: center; gap: 6px; }
    .control-btn:hover { background: var(--surface-elevated); }
    .control-btn.active { outline: 2px solid var(--primary); }
    .control-btn:disabled { opacity: .5; cursor: not-allowed; }
    .main-content { flex: 1; display: flex; flex-direction: row; background: var(--bg); }
    .viewer-container { flex: 1; position: relative; overflow: auto; background: var(--bg); }
    .pdf-viewer { display: flex; flex-direction: column; align-items: center; padding: 20px; min-height: 100%; }
    .pdf-page { background: #fff; margin-bottom: 20px; box-shadow: 0 4px 8px rgba(0,0,0,.3); border-radius: 4px; overflow: hidden; }
    .page-layer { position: relative; }
    .anno-overlay { position: absolute; inset: 0; pointer-events: none; user-select: none; }
    /* PDF.js text selection layer */
    .textLayer { position: absolute; inset: 0; pointer-events: auto; color: transparent; z-index: 1; user-select: text; }
    .textLayer span { position: absolute; white-space: pre; transform-origin: 0 0; }
    .textLayer ::selection { background: rgba(180, 213, 255, 0.35); }
    :root[data-theme="dark"] .textLayer ::selection { background: rgba(59, 130, 246, 0.35); }
    /* Text-only mode makes the text layer visible and hides canvas */
    .page-layer.text-only canvas { display: none; }
    .page-layer.text-only .textLayer { color: var(--text); }
    .anno-rect { position: absolute; border-radius: 2px; pointer-events: auto; cursor: pointer; }
    .anno-rect:hover { outline: 1px solid #3b82f6; }
    .selection-rect { position: absolute; border: 1px dashed #3b82f6; background: rgba(59,130,246,.15); pointer-events: none; }
    .annotations-panel { width: 280px; border-left: 1px solid var(--border); background: var(--surface); padding: 12px; overflow: auto; }
    .annotations-header { display: flex; align-items: center; justify-content: space-between; margin-bottom: 8px; font-weight: 600; }
    .anno-list { display: flex; flex-direction: column; gap: 8px; }
    .anno-item { display: flex; align-items: flex-start; gap: 8px; padding: 8px; border-radius: 6px; background: var(--surface-secondary); cursor: pointer; }
    .anno-item:hover { background: var(--surface-elevated); }
    .anno-dot { width: 10px; height: 10px; border-radius: 50%; margin-top: 4px; }
    .anno-note { font-size: 12px; color: var(--text-secondary); }
    .hidden-panel { display: none; }
    .loading { display: flex; flex-direction: column; align-items: center; justify-content: center; height: 400px; color: var(--text-secondary); gap: 16px; }
    .spinner { width: 40px; height: 40px; border: 3px solid var(--border); border-top: 3px solid var(--primary); border-radius: 50%; animation: spin 1s linear infinite; }
    @keyframes spin { 0%{transform:rotate(0)}100%{transform:rotate(360deg)} }
    .error { display: flex; flex-direction: column; align-items: center; justify-content: center; height: 400px; color: #ef4444; gap: 16px; text-align: center; padding: 40px; }
    .error-icon { font-size: 48px; opacity: .7; }
    .no-pdf { display: flex; flex-direction: column; align-items: center; justify-content: center; height: 400px; color: var(--text-secondary); gap: 16px; text-align: center; padding: 40px; }
    .hidden { display: none !important; }
    .status-bar { background: var(--surface); border-top: 1px solid var(--border); padding: 8px 24px; font-size: 12px; color: var(--text-secondary); text-align: center; }
    :root[data-theme="dark"] .pdf-viewer canvas { filter: invert(1) hue-rotate(180deg); }
    @media (max-width: 768px){ .header{padding:12px 16px; flex-direction:column; gap:12px; align-items:stretch} .paper-title{max-width:none} .controls{justify-content:center; flex-wrap:wrap; gap:12px} }
  </style>
</head>
<body>
  <div class="app">
    <header class="header">
      <div class="paper-info">
        <h1 class="paper-title" id="paper-title">Loading...</h1>
        <p class="paper-meta" id="paper-meta">Loading...</p>
      </div>
      <div class="controls">
        <button class="control-btn" id="prev-page" title="Previous Page">Prev</button>
        <span id="page-info" style="margin: 0 8px; min-width: 64px; text-align:center">‚Äî</span>
        <button class="control-btn" id="next-page" title="Next Page">Next</button>
        <button class="control-btn" id="zoom-out" title="Zoom Out" style="margin-left:12px">-</button>
        <button class="control-btn" id="zoom-in" title="Zoom In">+</button>
        <button class="control-btn" id="zoom-reset" title="Fit to Width">Fit</button>
        <button class="control-btn" id="toggle-text" title="Toggle Text Mode" style="margin-left:8px">Text</button>
        <input id="page-jump" type="number" min="1" value="1" style="width:70px; margin-left:8px" title="Jump to page" />
        <button class="control-btn" id="page-go" title="Go to page">Go</button>
        <div style="display:flex; gap:6px; align-items:center; margin-left:12px">
          <span style="font-size:12px; color:var(--text-secondary)">Color:</span>
          <button class="control-btn" data-color="#f59e0b" style="padding:4px 6px; background:#f59e0b; color:#000" title="Amber" id="color-amber">A</button>
          <button class="control-btn" data-color="#60a5fa" style="padding:4px 6px; background:#60a5fa; color:#000" title="Blue" id="color-blue">B</button>
          <button class="control-btn" data-color="#34d399" style="padding:4px 6px; background:#34d399; color:#000" title="Green" id="color-green">G</button>
          <button class="control-btn" data-color="#f472b6" style="padding:4px 6px; background:#f472b6; color:#000" title="Pink" id="color-pink">P</button>
          <button class="control-btn" data-color="#fde047" style="padding:4px 6px; background:#fde047; color:#000" title="Yellow" id="color-yellow">Y</button>
        </div>
        <button class="control-btn" id="toggle-annotations" style="margin-left:12px">Notes</button>
        <button class="control-btn" id="close-reader"><span>Close</span></button>
      </div>
    </header>

    <div class="main-content">
      <div class="viewer-container" id="viewer-container">
        <div class="pdf-viewer" id="pdf-viewer">
          <div class="loading" id="loading">
            <div class="spinner"></div>
            <p>Loading PDF...</p>
          </div>
          <div class="error hidden" id="error">
            <div class="error-icon">‚ö†Ô∏è</div>
            <h3>Failed to load PDF</h3>
            <p id="error-message">An error occurred while loading the PDF file.</p>
          </div>
          <div class="no-pdf hidden" id="no-pdf">
            <div class="error-icon">üìÑ</div>
            <h3>No PDF Available</h3>
            <p>This paper doesn't have a PDF file attached.</p>
          </div>
          <div id="page-container"></div>
        </div>
      </div>
      <aside class="annotations-panel hidden-panel" id="annotations-panel">
        <div class="annotations-header">
          <span>Annotations</span>
          <span id="anno-count">0</span>
        </div>
        <div class="anno-list" id="anno-list"></div>
      </aside>
    </div>

    <div class="status-bar" id="status-bar">Ready</div>
  </div>

  <script type="module">
    import { getDocument, GlobalWorkerOptions } from 'pdfjs-dist';
    // Note: pdfjs-dist v5 no longer exports renderTextLayer; we'll implement a minimal text-layer renderer here.
    import workerUrl from 'pdfjs-dist/build/pdf.worker.mjs?url';
    GlobalWorkerOptions.workerSrc = workerUrl;

      class PDFReader {
        constructor() {
          this.currentPaper = null;
          this.pdfDocument = null;
          this.currentPage = 1;
          this.totalPages = 0;
          this.scale = 1.0; // 1.0 means "fit to width"
          this.autoFitScale = 1.0;
          this.renderTask = null;
          this._resizeObs = null;
          this._resizeRAF = 0;
          this._lastContainerWidth = 0;
          this._isRendering = false;
          this._fallbackTimer = null;
          this._currentOverlay = null;
          this._isSelecting = false;
          this._startX = 0; this._startY = 0;
          this._selEl = null;
          this._selHandlersBound = false;
          this.currentColor = '#f59e0b';
          this.annotationsOpen = false;
          this.init();
        }

      async init() {
        this.setupEventListeners();
        this.setupIPC();
      }

      setupEventListeners() {
        document.getElementById('close-reader')?.addEventListener('click', () => {
          window.api['pdf-reader']['close-window']();
        });

        // Header controls
        document.getElementById('prev-page')?.addEventListener('click', (e) => {
          e.preventDefault(); e.stopPropagation();
          if (this.currentPage > 1) void this.goToPage(this.currentPage - 1);
        });
        document.getElementById('next-page')?.addEventListener('click', (e) => {
          e.preventDefault(); e.stopPropagation();
          if (this.currentPage < this.totalPages) void this.goToPage(this.currentPage + 1);
        });
        document.getElementById('zoom-in')?.addEventListener('click', () => this.zoomIn());
        document.getElementById('zoom-out')?.addEventListener('click', () => this.zoomOut());
        document.getElementById('zoom-reset')?.addEventListener('click', () => this.zoomReset());
        const textBtn = document.getElementById('toggle-text');
        textBtn?.addEventListener('click', () => {
          this.textOnly = !this.textOnly;
          textBtn.classList.toggle('active', this.textOnly);
          // re-render to apply visibility changes
          void this.renderCurrentPage();
        });

        // Page jump and Go
        const pageInput = document.getElementById('page-jump');
        const pageGoBtn = document.getElementById('page-go');
        pageGoBtn?.addEventListener('click', () => {
          if (!this.pdfDocument) return;
          const raw = (pageInput?.value ?? '').toString();
          const n = Number(raw);
          if (!Number.isFinite(n)) return;
          void this.goToPage(n);
        });
        pageInput?.addEventListener('keydown', (e) => {
          if (e.key === 'Enter') { e.preventDefault(); pageGoBtn?.click(); }
        });
        pageInput?.addEventListener('blur', () => {
          if (!this.pdfDocument || !pageInput) return;
          const n = Math.max(1, Math.min(Number(pageInput.value || 1), this.totalPages));
          pageInput.value = String(n);
        });

        // Color palette
        const colorButtons = Array.from(document.querySelectorAll('[data-color]'));
        const setActiveColor = (hex) => {
          this.currentColor = hex;
          colorButtons.forEach((btn) => btn.classList.toggle('active', (btn.getAttribute('data-color') || '').toLowerCase() === hex.toLowerCase()));
        };
        colorButtons.forEach((btn) => btn.addEventListener('click', () => {
          const hex = btn.getAttribute('data-color');
          if (hex) setActiveColor(hex);
        }));
        const initialColorBtn = document.querySelector(`[data-color="${this.currentColor}"]`);
        if (initialColorBtn) initialColorBtn.classList.add('active');
        const notesBtn = document.getElementById('toggle-annotations');
        notesBtn?.addEventListener('click', () => {
          this.annotationsOpen = !this.annotationsOpen;
          const panel = document.getElementById('annotations-panel');
          if (panel) panel.classList.toggle('hidden-panel', !this.annotationsOpen);
          if (this._currentOverlay) this._currentOverlay.style.pointerEvents = this.annotationsOpen ? 'auto' : 'none';
          const textLayer = document.querySelector('.textLayer');
          if (textLayer) textLayer.style.pointerEvents = this.annotationsOpen ? 'none' : 'auto';
          notesBtn.classList.toggle('active', this.annotationsOpen);
        });

        document.addEventListener('keydown', (e) => {
          switch (e.key) {
            case 'ArrowLeft': if (this.currentPage > 1) this.goToPage(this.currentPage - 1); break;
            case 'ArrowRight': if (this.currentPage < this.totalPages) this.goToPage(this.currentPage + 1); break;
            case 'Home': this.goToPage(1); break;
            case 'End': this.goToPage(this.totalPages); break;
            case 'Escape': window.api['pdf-reader']['close-window'](); break;
          }
        });

        const container = document.getElementById('viewer-container');
        if (container) this._lastContainerWidth = container.offsetWidth;
        this._resizeObs = new ResizeObserver(() => {
          if (!this.pdfDocument) return;
          if (!container) return;
          const w = container.offsetWidth;
          if (Math.abs(w - this._lastContainerWidth) < 2) return; // ignore tiny thrash
          this._lastContainerWidth = w;
          if (this._resizeRAF) cancelAnimationFrame(this._resizeRAF);
          this._resizeRAF = requestAnimationFrame(() => {
            if (this.currentPage > 0 && !this._isRendering) this.renderCurrentPage();
          });
        });
        this._resizeObs.observe(container);
      }

      setupIPC() {
        window.api.on('pdf-reader:paper-loaded', async (paper) => {
          this.currentPaper = paper;
          this.updatePaperInfo();
          await this.loadPDF();
        });
        this.applyThemeFromStorage();
        window.addEventListener('storage', (e) => { if (e.key === 'theme') this.applyThemeFromStorage(); });

        // Fallback: if no IPC payload arrives quickly, extract paperId from query and load
        try {
          const params = new URLSearchParams(window.location.search);
          const paperId = params.get('paperId');
          if (paperId) {
            this._fallbackTimer = window.setTimeout(async () => {
              if (!this.currentPaper) {
                try {
                  const paper = await window.api.papers.get(paperId);
                  if (paper) {
                    this.currentPaper = paper;
                    this.updatePaperInfo();
                    await this.loadPDF();
                  } else {
                    // If DB lookup fails, still attempt render with only file path
                    await this.loadPDFFromIdOnly(paperId);
                  }
                } catch (e) {
                  await this.loadPDFFromIdOnly(paperId);
                }
              }
            }, 800);
          }
        } catch {}
      }

      applyThemeFromStorage() {
        try { const t = localStorage.getItem('theme'); this.applyTheme(t === 'dark' ? 'dark' : 'light'); }
        catch { this.applyTheme('light'); }
      }
      applyTheme(theme) {
        if (theme === 'dark') document.documentElement.setAttribute('data-theme', 'dark');
        else document.documentElement.removeAttribute('data-theme');
      }

      updatePaperInfo() {
        if (!this.currentPaper) return;
        const title = this.currentPaper.title || 'Untitled Paper';
        const authors = Array.isArray(this.currentPaper.authors) ? this.currentPaper.authors.join(', ') : 'Unknown Authors';
        const venue = this.currentPaper.venue || '';
        const year = this.currentPaper.year || '';
        document.getElementById('paper-title').textContent = title;
        document.getElementById('paper-meta').textContent = [authors, venue, year].filter(Boolean).join(' ‚Ä¢ ');
      }

      async loadPDF() {
        if (!this.currentPaper) return;
        try {
          this.showLoading('Loading PDF...');
          const filePath = await window.api['pdf-reader']['get-file-path'](this.currentPaper.id);
          if (!filePath) return this.showNoPDF();

          const exists = await window.api['pdf-reader']['file-exists'](filePath);
          if (!exists) return this.showNoPDF();

          const arrayBuffer = await window.api.file.read(filePath);
          const data = new Uint8Array(arrayBuffer);

          this.pdfDocument = await getDocument({ data }).promise;
          this.totalPages = this.pdfDocument.numPages;
          this.currentPage = 1;
          this.updateToolbar();
          this.syncPageInput();
          await this.renderCurrentPage();
        } catch (err) {
          console.error(err);
          this.showError(`Failed to load PDF: ${err?.message || String(err)}`);
        }
      }

      async loadPDFFromIdOnly(paperId) {
        try {
          this.showLoading('Loading PDF...');
          const filePath = await window.api['pdf-reader']['get-file-path'](paperId);
          if (!filePath) return this.showNoPDF();
          const exists = await window.api['pdf-reader']['file-exists'](filePath);
          if (!exists) return this.showNoPDF();
          const arrayBuffer = await window.api.file.read(filePath);
          const data = new Uint8Array(arrayBuffer);
          this.pdfDocument = await getDocument({ data }).promise;
          this.totalPages = this.pdfDocument.numPages;
          this.currentPage = 1;
          this.updateToolbar();
          this.syncPageInput();
          await this.renderCurrentPage();
        } catch (err) {
          console.error(err);
          this.showError(`Failed to load PDF: ${err?.message || String(err)}`);
        }
      }

      async renderCurrentPage() {
        if (!this.pdfDocument || this.currentPage < 1 || this.currentPage > this.totalPages) return;
        try {
          if (this.renderTask) this.renderTask.cancel();
        this._isRendering = true;
        const page = await this.pdfDocument.getPage(this.currentPage);
        const viewer = document.getElementById('page-container');
        const container = document.getElementById('viewer-container');

          const baseViewport = page.getViewport({ scale: 1 });
          const fitScale = Math.max(0.1, ((container?.offsetWidth || 0) - 40) / baseViewport.width);
          this.autoFitScale = fitScale;
          const renderViewport = page.getViewport({ scale: this.scale === 1 ? fitScale : this.scale });

        const pageLayer = document.createElement('div');
          pageLayer.className = 'page-layer';
        if (this.textOnly) pageLayer.classList.add('text-only');
          const canvas = document.createElement('canvas');
          const ctx = canvas.getContext('2d');
          const dpr = window.devicePixelRatio || 1;
          canvas.width = Math.floor(renderViewport.width * dpr);
          canvas.height = Math.floor(renderViewport.height * dpr);
          canvas.style.width = Math.floor(renderViewport.width) + 'px';
          canvas.style.height = Math.floor(renderViewport.height) + 'px';
          const transform = dpr !== 1 ? [dpr, 0, 0, dpr, 0, 0] : null;
          this.renderTask = page.render({ canvasContext: ctx, viewport: renderViewport, transform });
          await this.renderTask.promise;
          canvas.className = 'pdf-page';
          pageLayer.style.width = Math.floor(renderViewport.width) + 'px';
          pageLayer.style.height = Math.floor(renderViewport.height) + 'px';
          const overlay = document.createElement('div');
          overlay.className = 'anno-overlay';
        // Add canvas
        pageLayer.appendChild(canvas);
        // Add text layer for selection/copy
        const textLayerDiv = document.createElement('div');
        textLayerDiv.className = 'textLayer';
        // When in notes mode, disable text interactions so drag creates highlight boxes
        textLayerDiv.style.pointerEvents = this.annotationsOpen ? 'none' : 'auto';
        pageLayer.appendChild(textLayerDiv);
        try {
          const textContent = await page.getTextContent();
          await this._renderTextLayerMinimal({ textContent, container: textLayerDiv, viewport: renderViewport });
        } catch (e) {
          console.warn('Text layer render failed:', e);
        }
        // Add annotation overlay last so highlights sit on top
        pageLayer.appendChild(overlay);
        if (viewer) {
          if (viewer.firstChild) viewer.replaceChild(pageLayer, viewer.firstChild);
          else viewer.appendChild(pageLayer);
        }

          this.attachSelectionHandlers(overlay);
          overlay.style.pointerEvents = this.annotationsOpen ? 'auto' : 'none';
          await this.renderAnnotations(overlay);
          this.hideLoading();
          this.updateToolbar();
          this.syncPageInput();
        } catch (err) {
          if (err?.name !== 'RenderingCancelledException') {
            console.error(err);
            this.showError(`Failed to render page: ${err?.message || String(err)}`);
          }
        }
        finally { this._isRendering = false; }
      }

      syncPageInput() {
        const pageInput = document.getElementById('page-jump');
        const pageGoBtn = document.getElementById('page-go');
        if (pageInput) {
          pageInput.disabled = !this.pdfDocument;
          pageInput.min = '1';
          pageInput.max = String(this.totalPages || 1);
          if (this.pdfDocument) pageInput.value = String(this.currentPage);
        }
        if (pageGoBtn) pageGoBtn.disabled = !this.pdfDocument;
      }

      async goToPage(n) {
        if (!this.pdfDocument) return;
        const target = Math.max(1, Math.min(Number(n), this.totalPages));
        if (target === this.currentPage) return;
        this.currentPage = target;
        this.updateToolbar();
        this.syncPageInput();
        await this.renderCurrentPage();
      }

      async _renderTextLayerMinimal({ textContent, container, viewport }) {
        try {
          if (!textContent || !container || !viewport) return;
          container.style.width = Math.floor(viewport.width) + 'px';
          container.style.height = Math.floor(viewport.height) + 'px';
          // Clear any previous nodes
          while (container.firstChild) container.removeChild(container.firstChild);
          const items = textContent.items || [];
          const vt = viewport.transform || [1,0,0,1,0,0];
          const mul = (m1, m2) => [
            m1[0]*m2[0] + m1[2]*m2[1],
            m1[1]*m2[0] + m1[3]*m2[1],
            m1[0]*m2[2] + m1[2]*m2[3],
            m1[1]*m2[2] + m1[3]*m2[3],
            m1[0]*m2[4] + m1[2]*m2[5] + m1[4],
            m1[1]*m2[4] + m1[3]*m2[5] + m1[5],
          ];
          for (const item of items) {
            const im = item.transform || [1,0,0,1,0,0];
            const m = mul(vt, im);
            const span = document.createElement('span');
            span.textContent = item.str || '';
            span.style.transform = `matrix(${m[0]}, ${m[1]}, ${m[2]}, ${m[3]}, ${m[4]}, ${m[5]})`;
            span.style.transformOrigin = '0 0';
            span.style.position = 'absolute';
            span.style.whiteSpace = 'pre';
            container.appendChild(span);
          }
        } catch (e) {
          console.warn('Minimal text layer failed', e);
        }
      }

      zoomIn() {
        if (!this.pdfDocument) return;
        if (this.scale === 1) this.scale = this.autoFitScale; // start from fitted scale
        this.scale = Math.min(this.scale * 1.25, 5);
        void this.renderCurrentPage();
      }

      zoomOut() {
        if (!this.pdfDocument) return;
        if (this.scale === 1) this.scale = this.autoFitScale; // start from fitted scale
        this.scale = Math.max(this.scale / 1.25, 0.25);
        void this.renderCurrentPage();
      }

      zoomReset() {
        if (!this.pdfDocument) return;
        this.scale = 1; // back to fit to width
        void this.renderCurrentPage();
      }

      updateToolbar() {
        const pageInfo = document.getElementById('page-info');
        if (pageInfo) pageInfo.textContent = (this.pdfDocument ? `${this.currentPage} / ${this.totalPages}` : '‚Äî');
        const prev = document.getElementById('prev-page');
        const next = document.getElementById('next-page');
        if (prev) prev.disabled = !this.pdfDocument || this.currentPage <= 1;
        if (next) next.disabled = !this.pdfDocument || this.currentPage >= this.totalPages;
        const zi = document.getElementById('zoom-in');
        const zo = document.getElementById('zoom-out');
        const zr = document.getElementById('zoom-reset');
        const atFit = this.scale === 1;
        if (zi) zi.disabled = !this.pdfDocument || (!atFit && this.scale >= 5);
        if (zo) zo.disabled = !this.pdfDocument || (!atFit && this.scale <= 0.25);
        if (zr) zr.disabled = !this.pdfDocument || atFit;
      }

      attachSelectionHandlers(overlay) {
        this._currentOverlay = overlay;
        overlay.style.pointerEvents = this.annotationsOpen ? 'auto' : 'none';

        const onMouseDown = (e) => {
          if (e.button !== 0) return; // left click only
          if (!this._currentOverlay) return;
          this._isSelecting = true;
          const rect = this._currentOverlay.getBoundingClientRect();
          this._startX = e.clientX - rect.left;
          this._startY = e.clientY - rect.top;
          this._selEl = document.createElement('div');
          this._selEl.className = 'selection-rect';
          this._selEl.style.left = `${this._startX}px`;
          this._selEl.style.top = `${this._startY}px`;
          this._selEl.style.width = '0px';
          this._selEl.style.height = '0px';
          this._currentOverlay.appendChild(this._selEl);
        };

        const onMouseMove = (e) => {
          if (!this._isSelecting || !this._selEl || !this._currentOverlay) return;
          const rect = this._currentOverlay.getBoundingClientRect();
          const currX = e.clientX - rect.left;
          const currY = e.clientY - rect.top;
          const x = Math.min(this._startX, currX);
          const y = Math.min(this._startY, currY);
          const w = Math.abs(currX - this._startX);
          const h = Math.abs(currY - this._startY);
          this._selEl.style.left = `${x}px`;
          this._selEl.style.top = `${y}px`;
          this._selEl.style.width = `${w}px`;
          this._selEl.style.height = `${h}px`;
        };

        const onMouseUp = async () => {
          if (!this._isSelecting) return;
          this._isSelecting = false;
          if (!this._selEl || !this._currentOverlay) return;
          const rect = this._currentOverlay.getBoundingClientRect();
          const x = parseFloat(this._selEl.style.left);
          const y = parseFloat(this._selEl.style.top);
          const w = parseFloat(this._selEl.style.width);
          const h = parseFloat(this._selEl.style.height);
          this._currentOverlay.removeChild(this._selEl);
          this._selEl = null;
          if (w < 5 || h < 5) return;

          const color = this.currentColor || '#f59e0b';
          const note = prompt('Add a note (optional):', '') || '';
          const nx = x / rect.width;
          const ny = y / rect.height;
          const nw = w / rect.width;
          const nh = h / rect.height;
          try {
            await this.addAnnotation({
              paperId: this.currentPaper.id,
              page: this.currentPage,
              color,
              note,
              tags: [],
              anchors: { region: { page: this.currentPage, x: nx, y: ny, width: nw, height: nh } },
            });
            await this.renderAnnotations(this._currentOverlay);
          } catch (err) {
            console.error('Failed to save annotation', err);
          }
        };

        overlay.addEventListener('mousedown', onMouseDown);
        if (!this._selHandlersBound) {
          window.addEventListener('mousemove', onMouseMove);
          window.addEventListener('mouseup', onMouseUp);
          this._selHandlersBound = true;
        }
      }

      async renderAnnotations(overlay) {
        overlay.querySelectorAll('.anno-rect').forEach((el) => el.remove());
        if (!this.currentPaper) return;
        try {
          const annos = await this.getAnnotationsByPaper(this.currentPaper.id);
          const pageAnnos = annos.filter((a) => (a.page ?? a.anchors?.region?.page) === this.currentPage);
          const rect = overlay.getBoundingClientRect();
          for (const a of pageAnnos) {
            const r = a.anchors?.region;
            if (!r) continue;
            const el = document.createElement('div');
            el.className = 'anno-rect';
            const px = r.x * rect.width;
            const py = r.y * rect.height;
            const pw = r.width * rect.width;
            const ph = r.height * rect.height;
            el.style.left = `${px}px`;
            el.style.top = `${py}px`;
            el.style.width = `${pw}px`;
            el.style.height = `${ph}px`;
            el.style.background = this.hexToRgba(a.color || '#f59e0b', 0.35);
            el.title = a.note || '';
            el.addEventListener('click', async (e) => {
              e.stopPropagation();
              const updated = prompt('Edit note (leave empty to keep):', a.note || '');
              if (updated !== null) {
                try { await this.updateAnnotation(a.id, { note: updated }); el.title = updated; }
                catch (err) { console.error('Failed to update note', err); }
              }
            });
            el.addEventListener('contextmenu', async (e) => {
              e.preventDefault(); e.stopPropagation();
              if (confirm('Delete this highlight?')) {
                try { await this.deleteAnnotation(a.id); el.remove(); }
                catch (err) { console.error('Failed to delete annotation', err); }
              }
            });
            overlay.appendChild(el);
          }
        } catch (err) {
          console.error('Failed to render annotations', err);
        }
      }

      // ---- Annotation storage wrappers (Electron IPC or localStorage fallback) ----
      async addAnnotation(payload) {
        try {
          if (window?.api?.annotations?.add) return await window.api.annotations.add(payload);
        } catch {}
        const key = `annos:${payload.paperId}`;
        const list = JSON.parse(localStorage.getItem(key) || '[]');
        const id = `${Date.now()}_${Math.random().toString(36).slice(2,8)}`;
        const anno = { id, ...payload };
        list.push(anno);
        localStorage.setItem(key, JSON.stringify(list));
        return anno;
      }
      async getAnnotationsByPaper(paperId) {
        try {
          if (window?.api?.annotations?.getByPaper) return await window.api.annotations.getByPaper(paperId);
        } catch {}
        const key = `annos:${paperId}`;
        return JSON.parse(localStorage.getItem(key) || '[]');
      }
      async updateAnnotation(id, patch) {
        try {
          if (window?.api?.annotations?.update) return await window.api.annotations.update(id, patch);
        } catch {}
        // localStorage fallback
        const paperId = this.currentPaper?.id;
        if (!paperId) return;
        const key = `annos:${paperId}`;
        const list = JSON.parse(localStorage.getItem(key) || '[]');
        const idx = list.findIndex((a) => a.id === id);
        if (idx >= 0) { list[idx] = { ...list[idx], ...patch }; localStorage.setItem(key, JSON.stringify(list)); }
      }
      async deleteAnnotation(id) {
        try {
          if (window?.api?.annotations?.delete) return await window.api.annotations.delete(id);
        } catch {}
        const paperId = this.currentPaper?.id;
        if (!paperId) return;
        const key = `annos:${paperId}`;
        const list = JSON.parse(localStorage.getItem(key) || '[]');
        const next = list.filter((a) => a.id !== id);
        localStorage.setItem(key, JSON.stringify(next));
      }

      hexToRgba(hex, alpha) {
        try {
          let h = String(hex || '').replace('#','').trim();
          if (h.length === 3) h = h.split('').map((c) => c + c).join('');
          if (h.length !== 6) return `rgba(245, 158, 11, ${alpha})`; // default amber
          const r = parseInt(h.substring(0,2),16);
          const g = parseInt(h.substring(2,4),16);
          const b = parseInt(h.substring(4,6),16);
          return `rgba(${r}, ${g}, ${b}, ${alpha})`;
        } catch { return `rgba(245, 158, 11, ${alpha})`; }
      }

      showLoading(msg = 'Loading...') {
        const l = document.getElementById('loading');
        if (l) {
          const p = l.querySelector('p');
          if (p) p.textContent = msg;
          l.classList.remove('hidden');
        }
        const e = document.getElementById('error'); if (e) e.classList.add('hidden');
        const n = document.getElementById('no-pdf'); if (n) n.classList.add('hidden');
      }

      hideLoading() { const l = document.getElementById('loading'); if (l) l.classList.add('hidden'); }

      showError(m) {
        const em = document.getElementById('error-message'); if (em) em.textContent = m;
        const e = document.getElementById('error'); if (e) e.classList.remove('hidden');
        const l = document.getElementById('loading'); if (l) l.classList.add('hidden');
        const n = document.getElementById('no-pdf'); if (n) n.classList.add('hidden');
      }

      showNoPDF() {
        const n = document.getElementById('no-pdf'); if (n) n.classList.remove('hidden');
        const l = document.getElementById('loading'); if (l) l.classList.add('hidden');
        const e = document.getElementById('error'); if (e) e.classList.add('hidden');
      }
    }

    document.addEventListener('DOMContentLoaded', () => new PDFReader());
  </script>
</body>
</html>
